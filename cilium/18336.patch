diff --git a/bpf/bpf_lxc.c b/bpf/bpf_lxc.c
index e5375b148c..aa84cb3394 100644
--- a/bpf/bpf_lxc.c
+++ b/bpf/bpf_lxc.c
@@ -30,6 +30,14 @@
 #include "lib/nat46.h"
 #include "lib/identity.h"
 #include "lib/policy.h"
+
+/* Override LB_SELECTION initially defined in node_config.h to force bpf_lxc to use the random backend selection
+ * algorithm for in-cluster traffic. Otherwise, it will fail with the Maglev hash algorithm because Cilium doesn't provision
+ * the Maglev table for ClusterIP unless bpf.lbExternalClusterIP is set to true.
+ */
+#undef LB_SELECTION
+#define LB_SELECTION LB_SELECTION_RANDOM
+
 #include "lib/lb.h"
 #include "lib/drop.h"
 #include "lib/dbg.h"
diff --git a/pkg/service/service.go b/pkg/service/service.go
index 0c794d3d1e..51e5a1d2ee 100644
--- a/pkg/service/service.go
+++ b/pkg/service/service.go
@@ -116,7 +116,11 @@ func (svc *svcInfo) useMaglev() bool {
 	return option.Config.NodePortAlg == option.NodePortAlgMaglev &&
 		((svc.svcType == lb.SVCTypeNodePort && !isWildcardAddr(svc.frontend)) ||
 			svc.svcType == lb.SVCTypeExternalIPs ||
-			svc.svcType == lb.SVCTypeLoadBalancer)
+			svc.svcType == lb.SVCTypeLoadBalancer ||
+			// Provision the Maglev LUT for ClusterIP only if ExternalClusterIP is enabled
+			// because ClusterIP can also be accessed from outside with this setting.
+			// We don't do it unconditionally to avoid increasing memory footprint.
+			(option.Config.ExternalClusterIP && svc.svcType == lb.SVCTypeClusterIP))
 }
 
 // Service is a service handler. Its main responsibility is to reflect
diff --git a/pkg/service/service_test.go b/pkg/service/service_test.go
index be9381285d..415b91a7cf 100644
--- a/pkg/service/service_test.go
+++ b/pkg/service/service_test.go
@@ -22,14 +22,15 @@ import (
 )
 
 type ManagerTestSuite struct {
-	svc                       *Service
-	lbmap                     *mockmaps.LBMockMap // for accessing public fields
-	svcHealth                 *healthserver.MockHealthHTTPServerFactory
-	prevOptionSessionAffinity bool
-	prevOptionLBSourceRanges  bool
-	prevOptionNPAlgo          string
-	prevOptionDPMode          string
-	ipv6                      bool
+	svc                         *Service
+	lbmap                       *mockmaps.LBMockMap // for accessing public fields
+	svcHealth                   *healthserver.MockHealthHTTPServerFactory
+	prevOptionSessionAffinity   bool
+	prevOptionLBSourceRanges    bool
+	prevOptionNPAlgo            string
+	prevOptionDPMode            string
+	prevOptionExternalClusterIP bool
+	ipv6                        bool
 }
 
 var _ = Suite(&ManagerTestSuite{})
@@ -53,6 +54,7 @@ func (m *ManagerTestSuite) SetUpTest(c *C) {
 
 	m.prevOptionNPAlgo = option.Config.NodePortAlg
 	m.prevOptionDPMode = option.Config.DatapathMode
+	m.prevOptionExternalClusterIP = option.Config.ExternalClusterIP
 
 	m.ipv6 = option.Config.EnableIPv6
 }
@@ -64,6 +66,7 @@ func (m *ManagerTestSuite) TearDownTest(c *C) {
 	option.Config.EnableSVCSourceRangeCheck = m.prevOptionLBSourceRanges
 	option.Config.NodePortAlg = m.prevOptionNPAlgo
 	option.Config.DatapathMode = m.prevOptionDPMode
+	option.Config.ExternalClusterIP = m.prevOptionExternalClusterIP
 	option.Config.EnableIPv6 = m.ipv6
 }
 
@@ -765,6 +768,57 @@ func (m *ManagerTestSuite) TestUpsertServiceWithTerminatingBackends(c *C) {
 	c.Assert(len(m.lbmap.AffinityMatch[uint16(id1)]), Equals, 0)
 }
 
+// Tests whether upsert service provisions the Maglev LUT for ClusterIP,
+// if ExternalClusterIP is true
+func (m *ManagerTestSuite) TestUpsertServiceWithExternalClusterIP(c *C) {
+	option.Config.NodePortAlg = option.NodePortAlgMaglev
+	option.Config.ExternalClusterIP = true
+	p := &lb.SVC{
+		Frontend:      frontend1,
+		Backends:      backends1,
+		Type:          lb.SVCTypeClusterIP,
+		TrafficPolicy: lb.SVCTrafficPolicyCluster,
+		Name:          "svc1",
+		Namespace:     "ns1",
+	}
+
+	created, id1, err := m.svc.UpsertService(p)
+
+	c.Assert(err, IsNil)
+	c.Assert(created, Equals, true)
+	c.Assert(id1, Equals, lb.ID(1))
+	c.Assert(len(m.lbmap.ServiceByID[uint16(id1)].Backends), Equals, 2)
+	c.Assert(len(m.lbmap.BackendByID), Equals, 2)
+	c.Assert(m.svc.svcByID[id1].svcName, Equals, "svc1")
+	c.Assert(m.svc.svcByID[id1].svcNamespace, Equals, "ns1")
+	c.Assert(m.lbmap.DummyMaglevTable[uint16(id1)], Equals, len(backends1))
+}
+
+// Tests whether upsert service doesn't provision the Maglev LUT for ClusterIP,
+// if ExternalClusterIP is false
+func (m *ManagerTestSuite) TestUpsertServiceWithOutExternalClusterIP(c *C) {
+	option.Config.NodePortAlg = option.NodePortAlgMaglev
+	p := &lb.SVC{
+		Frontend:      frontend1,
+		Backends:      backends1,
+		Type:          lb.SVCTypeClusterIP,
+		TrafficPolicy: lb.SVCTrafficPolicyCluster,
+		Name:          "svc1",
+		Namespace:     "ns1",
+	}
+
+	created, id1, err := m.svc.UpsertService(p)
+
+	c.Assert(err, IsNil)
+	c.Assert(created, Equals, true)
+	c.Assert(id1, Equals, lb.ID(1))
+	c.Assert(len(m.lbmap.ServiceByID[uint16(id1)].Backends), Equals, 2)
+	c.Assert(len(m.lbmap.BackendByID), Equals, 2)
+	c.Assert(m.svc.svcByID[id1].svcName, Equals, "svc1")
+	c.Assert(m.svc.svcByID[id1].svcNamespace, Equals, "ns1")
+	c.Assert(m.lbmap.DummyMaglevTable[uint16(id1)], Equals, 0)
+}
+
 // Tests terminating backend entries are removed after service restore.
 func (m *ManagerTestSuite) TestRestoreServiceWithTerminatingBackends(c *C) {
 	option.Config.NodePortAlg = option.NodePortAlgMaglev
diff --git a/test/k8sT/Services.go b/test/k8sT/Services.go
index 5b3503187f..ecbb4664f0 100644
--- a/test/k8sT/Services.go
+++ b/test/k8sT/Services.go
@@ -254,6 +254,9 @@ var _ = SkipDescribeIf(helpers.RunsOn54Kernel, "K8sServicesTest", func() {
 			BeforeAll(func() {
 				DeployCiliumOptionsAndDNS(kubectl, ciliumFilename, map[string]string{
 					"hostServices.hostNamespaceOnly": "true",
+					// Enable Maglev to check if traffic destined to ClusterIP from Pod is properly handled
+					// by bpf_lxc.c using LB_SELECTION_RANDOM even if Maglev is enabled.
+					"loadBalancer.algorithm": "maglev",
 				})
 
 				yamls = []string{"demo_ds.yaml"}
@@ -740,6 +743,9 @@ Secondary Interface %s :: IPv4: (%s, %s), IPv6: (%s, %s)`,
 			BeforeAll(func() {
 				DeployCiliumOptionsAndDNS(kubectl, ciliumFilename, map[string]string{
 					"bpf.lbExternalClusterIP": "true",
+					// Enable Maglev to check if the Maglev LUT for ClusterIP is properly populated,
+					// and external clients can access ClusterIP with it.
+					"loadBalancer.algorithm": "maglev",
 				})
 				clusterIP, _, err := kubectl.GetServiceHostPort(helpers.DefaultNamespace, appServiceName)
 				svcIP = clusterIP
