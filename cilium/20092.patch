diff --git a/Documentation/gettingstarted/kubeproxy-free.rst b/Documentation/gettingstarted/kubeproxy-free.rst
index 9e8110d048..6db814b51e 100644
--- a/Documentation/gettingstarted/kubeproxy-free.rst
+++ b/Documentation/gettingstarted/kubeproxy-free.rst
@@ -1331,6 +1331,42 @@ attempting to keep them in REACHABLE state. The refresh interval can be changed
 through a ``--arping-refresh-period=30s`` flag passed to the cilium-agent. The default
 period is ``30s`` which corresponds to the kernel's base reachable time.
 
+The neighbor discovery supports multi-device environments where each node has multiple devices
+and multiple next-hops to another node. The Cilium agent pushes neighbor entries for all target
+devices, including the direct routing device. Currently, it supports one next-hop per device.
+The following example illustrates how the neighbor discovery works in a multi-device environment.
+Each node has two devices connected to different L3 networks (10.69.0.64/26 and 10.69.0.128/26),
+and global scope addresses each (10.69.0.1/26 and 10.69.0.2/26). A next-hop from node1 to node2 is
+either ``10.69.0.66 dev eno1`` or ``10.69.0.130 dev eno2``. The Cilium agent pushes neighbor
+entries for both ``10.69.0.66 dev eno1`` and ``10.69.0.130 dev eno2`` in this case.
+
+::
+
+    +---------------+     +---------------+
+    |    node1      |     |    node2      |
+    | 10.69.0.1/26  |     | 10.69.0.2/26  |
+    |           eno1+-----+eno1           |
+    |           |   |     |   |           |
+    | 10.69.0.65/26 |     |10.69.0.66/26  |
+    |               |     |               |
+    |           eno2+-----+eno2           |
+    |           |   |     | |             |
+    | 10.69.0.129/26|     | 10.69.0.130/26|
+    +---------------+     +---------------+
+
+With, on node1:
+
+.. code-block:: shell-session
+
+    $ ip route show
+    10.69.0.2
+            nexthop via 10.69.0.66 dev eno1 weight 1
+            nexthop via 10.69.0.130 dev eno2 weight 1
+
+    $ ip neigh show
+    10.69.0.66 dev eno1 lladdr 96:eb:75:fd:89:fd extern_learn  REACHABLE
+    10.69.0.130 dev eno2 lladdr 52:54:00:a6:62:56 extern_learn  REACHABLE
+
 External Access To ClusterIP Services
 *************************************
 
diff --git a/pkg/datapath/linux/node.go b/pkg/datapath/linux/node.go
index 6363664c6f..7f5d8fb727 100644
--- a/pkg/datapath/linux/node.go
+++ b/pkg/datapath/linux/node.go
@@ -8,12 +8,17 @@ import (
 	"encoding/json"
 	"errors"
 	"fmt"
+	"io"
 	"net"
 	"os"
 	"path/filepath"
-	"reflect"
 	"time"
 
+	"github.com/prometheus/client_golang/prometheus"
+	"github.com/sirupsen/logrus"
+	"github.com/vishvananda/netlink"
+	"golang.org/x/sys/unix"
+
 	"github.com/cilium/cilium/pkg/cidr"
 	"github.com/cilium/cilium/pkg/counter"
 	"github.com/cilium/cilium/pkg/datapath"
@@ -29,11 +34,6 @@ import (
 	"github.com/cilium/cilium/pkg/node"
 	nodeTypes "github.com/cilium/cilium/pkg/node/types"
 	"github.com/cilium/cilium/pkg/option"
-
-	"github.com/prometheus/client_golang/prometheus"
-	"github.com/sirupsen/logrus"
-	"github.com/vishvananda/netlink"
-	"golang.org/x/sys/unix"
 )
 
 const (
@@ -59,9 +59,9 @@ type linuxNodeHandler struct {
 	nodes                map[nodeTypes.Identity]*nodeTypes.Node
 	enableNeighDiscovery bool
 	neighLock            lock.Mutex // protects neigh* fields below
-	neighDiscoveryLink   netlink.Link
-	neighNextHopByNode4  map[nodeTypes.Identity]string // val = string(net.IP)
-	neighNextHopByNode6  map[nodeTypes.Identity]string // val = string(net.IP)
+	neighDiscoveryLinks  []netlink.Link
+	neighNextHopByNode4  map[nodeTypes.Identity]map[string]string // val = (key=link, value=string(net.IP))
+	neighNextHopByNode6  map[nodeTypes.Identity]map[string]string // val = (key=link, value=string(net.IP))
 	// All three mappings below hold both IPv4 and IPv6 entries.
 	neighNextHopRefCount   counter.StringCounter
 	neighByNextHop         map[string]*netlink.Neigh // key = string(net.IP)
@@ -78,8 +78,8 @@ func NewNodeHandler(datapathConfig DatapathConfiguration, nodeAddressing datapat
 		nodeAddressing:         nodeAddressing,
 		datapathConfig:         datapathConfig,
 		nodes:                  map[nodeTypes.Identity]*nodeTypes.Node{},
-		neighNextHopByNode4:    map[nodeTypes.Identity]string{},
-		neighNextHopByNode6:    map[nodeTypes.Identity]string{},
+		neighNextHopByNode4:    map[nodeTypes.Identity]map[string]string{},
+		neighNextHopByNode6:    map[nodeTypes.Identity]map[string]string{},
 		neighNextHopRefCount:   counter.StringCounter{},
 		neighByNextHop:         map[string]*netlink.Neigh{},
 		neighLastPingByNextHop: map[string]time.Time{},
@@ -649,9 +649,9 @@ func (n *linuxNodeHandler) encryptNode(newNode *nodeTypes.Node) {
 
 }
 
-func getNextHopIP(nodeIP net.IP) (nextHopIP net.IP, err error) {
+func getNextHopIP(nodeIP net.IP, link netlink.Link) (nextHopIP net.IP, err error) {
 	// Figure out whether nodeIP is directly reachable (i.e. in the same L2)
-	routes, err := netlink.RouteGet(nodeIP)
+	routes, err := netlink.RouteGetWithOptions(nodeIP, &netlink.RouteGetOptions{Oif: link.Attrs().Name})
 	if err != nil {
 		return nil, fmt.Errorf("failed to retrieve route for remote node IP: %w", err)
 	}
@@ -768,7 +768,7 @@ func (n *linuxNodeHandler) insertNeighbor4(ctx context.Context, newNode *nodeTyp
 		logfields.IPAddr:    newNodeIP,
 	})
 
-	nextHopIPv4, err := getNextHopIP(nextHopIPv4)
+	nextHopIPv4, err := getNextHopIP(nextHopIPv4, link)
 	if err != nil {
 		scopedLog.WithError(err).Info("Unable to determine next hop address")
 		return
@@ -779,8 +779,14 @@ func (n *linuxNodeHandler) insertNeighbor4(ctx context.Context, newNode *nodeTyp
 	n.neighLock.Lock()
 	defer n.neighLock.Unlock()
 
+	nextHopByLink, found := n.neighNextHopByNode4[newNode.Identity()]
+	if !found {
+		nextHopByLink = make(map[string]string)
+		n.neighNextHopByNode4[newNode.Identity()] = nextHopByLink
+	}
+
 	nextHopIsNew := false
-	if existingNextHopStr, found := n.neighNextHopByNode4[newNode.Identity()]; found {
+	if existingNextHopStr, found := nextHopByLink[link.Attrs().Name]; found {
 		if existingNextHopStr != nextHopStr {
 			if n.neighNextHopRefCount.Delete(existingNextHopStr) {
 				neigh, found := n.neighByNextHop[existingNextHopStr]
@@ -813,7 +819,7 @@ func (n *linuxNodeHandler) insertNeighbor4(ctx context.Context, newNode *nodeTyp
 		nextHopIsNew = n.neighNextHopRefCount.Add(nextHopStr)
 	}
 
-	n.neighNextHopByNode4[newNode.Identity()] = nextHopStr
+	n.neighNextHopByNode4[newNode.Identity()][link.Attrs().Name] = nextHopStr
 	nh := NextHop{
 		Name:  nextHopStr,
 		IP:    nextHopIPv4,
@@ -833,7 +839,7 @@ func (n *linuxNodeHandler) insertNeighbor6(ctx context.Context, newNode *nodeTyp
 		logfields.IPAddr:    newNodeIP,
 	})
 
-	nextHopIPv6, err := getNextHopIP(nextHopIPv6)
+	nextHopIPv6, err := getNextHopIP(nextHopIPv6, link)
 	if err != nil {
 		scopedLog.WithError(err).Info("Unable to determine next hop address")
 		return
@@ -844,8 +850,14 @@ func (n *linuxNodeHandler) insertNeighbor6(ctx context.Context, newNode *nodeTyp
 	n.neighLock.Lock()
 	defer n.neighLock.Unlock()
 
+	nextHopByLink, found := n.neighNextHopByNode6[newNode.Identity()]
+	if !found {
+		nextHopByLink = make(map[string]string)
+		n.neighNextHopByNode6[newNode.Identity()] = nextHopByLink
+	}
+
 	nextHopIsNew := false
-	if existingNextHopStr, found := n.neighNextHopByNode6[newNode.Identity()]; found {
+	if existingNextHopStr, found := nextHopByLink[link.Attrs().Name]; found {
 		if existingNextHopStr != nextHopStr {
 			if n.neighNextHopRefCount.Delete(existingNextHopStr) {
 				// nextHop has changed and nobody else is using it, so remove the old one.
@@ -879,7 +891,7 @@ func (n *linuxNodeHandler) insertNeighbor6(ctx context.Context, newNode *nodeTyp
 		nextHopIsNew = n.neighNextHopRefCount.Add(nextHopStr)
 	}
 
-	n.neighNextHopByNode6[newNode.Identity()] = nextHopStr
+	n.neighNextHopByNode6[newNode.Identity()][link.Attrs().Name] = nextHopStr
 	nh := NextHop{
 		Name:  nextHopStr,
 		IP:    nextHopIPv6,
@@ -897,22 +909,26 @@ func (n *linuxNodeHandler) insertNeighbor6(ctx context.Context, newNode *nodeTyp
 // which tries to update neighbor entries previously inserted by insertNeighbor().
 // In this case the kernel refreshes the entry via NTF_USE.
 func (n *linuxNodeHandler) insertNeighbor(ctx context.Context, newNode *nodeTypes.Node, refresh bool) {
-	var link netlink.Link
+	var links []netlink.Link
 
 	n.neighLock.Lock()
-	if n.neighDiscoveryLink == nil || reflect.ValueOf(n.neighDiscoveryLink).IsNil() {
+	if n.neighDiscoveryLinks == nil || len(n.neighDiscoveryLinks) == 0 {
 		n.neighLock.Unlock()
 		// Nothing to do - the discovery link was not set yet
 		return
 	}
-	link = n.neighDiscoveryLink
+	links = n.neighDiscoveryLinks
 	n.neighLock.Unlock()
 
 	if newNode.GetNodeIP(false).To4() != nil {
-		n.insertNeighbor4(ctx, newNode, link, refresh)
+		for _, l := range links {
+			n.insertNeighbor4(ctx, newNode, l, refresh)
+		}
 	}
 	if newNode.GetNodeIP(true).To16() != nil {
-		n.insertNeighbor6(ctx, newNode, link, refresh)
+		for _, l := range links {
+			n.insertNeighbor6(ctx, newNode, l, refresh)
+		}
 	}
 }
 
@@ -944,23 +960,27 @@ func (n *linuxNodeHandler) deleteNeighborCommon(nextHopStr string) {
 func (n *linuxNodeHandler) deleteNeighbor4(oldNode *nodeTypes.Node) {
 	n.neighLock.Lock()
 	defer n.neighLock.Unlock()
-	nextHopStr, found := n.neighNextHopByNode4[oldNode.Identity()]
+	nextHopByLink, found := n.neighNextHopByNode4[oldNode.Identity()]
 	if !found {
 		return
 	}
 	defer func() { delete(n.neighNextHopByNode4, oldNode.Identity()) }()
-	n.deleteNeighborCommon(nextHopStr)
+	for _, nextHopStr := range nextHopByLink {
+		n.deleteNeighborCommon(nextHopStr)
+	}
 }
 
 func (n *linuxNodeHandler) deleteNeighbor6(oldNode *nodeTypes.Node) {
 	n.neighLock.Lock()
 	defer n.neighLock.Unlock()
-	nextHopStr, found := n.neighNextHopByNode6[oldNode.Identity()]
+	nextHopByLink, found := n.neighNextHopByNode6[oldNode.Identity()]
 	if !found {
 		return
 	}
 	defer func() { delete(n.neighNextHopByNode6, oldNode.Identity()) }()
-	n.deleteNeighborCommon(nextHopStr)
+	for _, nextHopStr := range nextHopByLink {
+		n.deleteNeighborCommon(nextHopStr)
+	}
 }
 
 func (n *linuxNodeHandler) deleteNeighbor(oldNode *nodeTypes.Node) {
@@ -1467,17 +1487,21 @@ func (n *linuxNodeHandler) NodeConfigurationChanged(newConfig datapath.LocalNode
 	n.nodeConfig = newConfig
 
 	if n.nodeConfig.EnableIPv4 || n.nodeConfig.EnableIPv6 {
-		ifaceName := ""
+		var ifaceNames []string
 		switch {
 		case !option.Config.EnableL2NeighDiscovery:
 			n.enableNeighDiscovery = false
 		case option.Config.EnableNodePort:
-			mac, err := link.GetHardwareAddr(option.Config.DirectRoutingDevice)
+			var targetDevices []string
+			targetDevices = append(targetDevices, option.Config.DirectRoutingDevice)
+			targetDevices = append(targetDevices, option.Config.Devices...)
+
+			var err error
+			ifaceNames, err = filterL2Devices(targetDevices)
 			if err != nil {
 				return err
 			}
-			ifaceName = option.Config.DirectRoutingDevice
-			n.enableNeighDiscovery = mac != nil // No need to arping for L2-less devices
+			n.enableNeighDiscovery = len(ifaceNames) != 0 // No need to arping for L2-less devices
 		case n.nodeConfig.EnableIPSec &&
 			option.Config.Tunnel == option.TunnelDisabled &&
 			len(option.Config.EncryptInterface) != 0:
@@ -1485,21 +1509,25 @@ func (n *linuxNodeHandler) NodeConfigurationChanged(newConfig datapath.LocalNode
 			// interface so pick first interface in the list. On
 			// kernels with FIB lookup helpers we do a lookup from
 			// the datapath side and ignore this value.
-			ifaceName = option.Config.EncryptInterface[0]
+			ifaceNames = append(ifaceNames, option.Config.EncryptInterface[0])
 			n.enableNeighDiscovery = true
 		}
 
 		if n.enableNeighDiscovery {
-			link, err := netlink.LinkByName(ifaceName)
-			if err != nil {
-				return fmt.Errorf("cannot find link by name %s for neighbor discovery: %w",
-					ifaceName, err)
+			var neighDiscoveryLinks []netlink.Link
+			for _, ifaceName := range ifaceNames {
+				l, err := netlink.LinkByName(ifaceName)
+				if err != nil {
+					return fmt.Errorf("cannot find link by name %s for neighbor discovery: %w",
+						ifaceName, err)
+				}
+				neighDiscoveryLinks = append(neighDiscoveryLinks, l)
 			}
 
 			// Store neighDiscoveryLink so that we can remove the ARP
 			// PERM entries when cilium-agent starts with neigh discovery
 			// disabled next time.
-			err = storeNeighLink(option.Config.StateDir, ifaceName)
+			err := storeNeighLink(option.Config.StateDir, ifaceNames)
 			if err != nil {
 				log.WithError(err).Warning("Unable to store neighbor discovery iface." +
 					" Removing PERM neighbor entries upon cilium-agent init when neighbor" +
@@ -1509,7 +1537,7 @@ func (n *linuxNodeHandler) NodeConfigurationChanged(newConfig datapath.LocalNode
 			// neighDiscoveryLink can be accessed by a concurrent insertNeighbor
 			// goroutine.
 			n.neighLock.Lock()
-			n.neighDiscoveryLink = link
+			n.neighDiscoveryLinks = neighDiscoveryLinks
 			n.neighLock.Unlock()
 		}
 	}
@@ -1565,6 +1593,26 @@ func (n *linuxNodeHandler) NodeConfigurationChanged(newConfig datapath.LocalNode
 	return nil
 }
 
+func filterL2Devices(devices []string) ([]string, error) {
+	// Eliminate duplicates
+	deviceSets := make(map[string]struct{})
+	for _, d := range devices {
+		deviceSets[d] = struct{}{}
+	}
+
+	var l2devices []string
+	for k := range deviceSets {
+		mac, err := link.GetHardwareAddr(k)
+		if err != nil {
+			return nil, err
+		}
+		if mac != nil {
+			l2devices = append(l2devices, k)
+		}
+	}
+	return l2devices, nil
+}
+
 // NodeValidateImplementation is called to validate the implementation of the
 // node in the datapath
 func (n *linuxNodeHandler) NodeValidateImplementation(nodeToValidate nodeTypes.Node) error {
@@ -1720,13 +1768,13 @@ func (n *linuxNodeHandler) NodeCleanNeighborsLink(l netlink.Link, migrateOnly bo
 // deleted (and the new agent instance did not see the delete event during the
 // down/up cycle).
 func (n *linuxNodeHandler) NodeCleanNeighbors(migrateOnly bool) {
-	linkName, err := loadNeighLink(option.Config.StateDir)
+	linkNames, err := loadNeighLink(option.Config.StateDir)
 	if err != nil {
 		log.WithError(err).Error("Unable to load neighbor discovery iface name" +
 			" for removing PERM neighbor entries")
 		return
 	}
-	if len(linkName) == 0 {
+	if len(linkNames) == 0 {
 		return
 	}
 
@@ -1739,54 +1787,74 @@ func (n *linuxNodeHandler) NodeCleanNeighbors(migrateOnly bool) {
 		}
 	}()
 
-	l, err := netlink.LinkByName(linkName)
-	if err != nil {
-		// If the link is not found we don't need to keep retrying cleaning
-		// up the neihbor entries so we can keep successClean=true
-		if _, ok := err.(netlink.LinkNotFoundError); !ok {
-			log.WithError(err).WithFields(logrus.Fields{
-				logfields.Device: linkName,
-			}).Error("Unable to remove PERM neighbor entries of network device")
-			successClean = false
+	for _, linkName := range linkNames {
+		l, err := netlink.LinkByName(linkName)
+		if err != nil {
+			// If the link is not found we don't need to keep retrying cleaning
+			// up the neihbor entries so we can keep successClean=true
+			if _, ok := err.(netlink.LinkNotFoundError); !ok {
+				log.WithError(err).WithFields(logrus.Fields{
+					logfields.Device: linkName,
+				}).Error("Unable to remove PERM neighbor entries of network device")
+				successClean = false
+			}
+			continue
 		}
-		return
-	}
 
-	successClean = n.NodeCleanNeighborsLink(l, migrateOnly)
+		successClean = n.NodeCleanNeighborsLink(l, migrateOnly)
+	}
 }
 
-func storeNeighLink(dir string, name string) error {
+func storeNeighLink(dir string, names []string) error {
 	configFileName := filepath.Join(dir, neighFileName)
 	f, err := os.Create(configFileName)
 	if err != nil {
 		return fmt.Errorf("unable to create '%s': %w", configFileName, err)
 	}
 	defer f.Close()
-	nl := NeighLink{Name: name}
-	err = json.NewEncoder(f).Encode(nl)
+
+	var nls []NeighLink
+	for _, name := range names {
+		nls = append(nls, NeighLink{Name: name})
+	}
+	err = json.NewEncoder(f).Encode(nls)
 	if err != nil {
-		return fmt.Errorf("unable to encode '%+v': %w", nl, err)
+		return fmt.Errorf("unable to encode '%+v': %w", nls, err)
 	}
 	return nil
 }
 
-func loadNeighLink(dir string) (string, error) {
+func loadNeighLink(dir string) ([]string, error) {
 	configFileName := filepath.Join(dir, neighFileName)
 	f, err := os.Open(configFileName)
 	if err != nil {
 		if os.IsNotExist(err) {
-			return "", nil
+			return nil, nil
 		}
-		return "", fmt.Errorf("unable to open '%s': %w", configFileName, err)
+		return nil, fmt.Errorf("unable to open '%s': %w", configFileName, err)
 	}
 	defer f.Close()
+
+	// Ensure backward compatibility
 	var nl NeighLink
+	if err = json.NewDecoder(f).Decode(&nl); err == nil {
+		if len(nl.Name) > 0 {
+			return []string{nl.Name}, nil
+		}
+	}
 
-	err = json.NewDecoder(f).Decode(&nl)
-	if err != nil {
-		return "", fmt.Errorf("unable to decode '%s': %w", configFileName, err)
+	var nls []NeighLink
+	if _, err := f.Seek(0, io.SeekStart); err != nil {
+		return nil, err
+	}
+	if err := json.NewDecoder(f).Decode(&nls); err != nil {
+		return nil, fmt.Errorf("unable to decode '%s': %w", configFileName, err)
+	}
+	var names []string
+	for _, nl := range nls {
+		names = append(names, nl.Name)
 	}
-	return nl.Name, nil
+	return names, nil
 }
 
 // NodeDeviceNameWithDefaultRoute returns the node's device name which
diff --git a/pkg/datapath/linux/node_linux_test.go b/pkg/datapath/linux/node_linux_test.go
index c3c52b66b9..9618f210a7 100644
--- a/pkg/datapath/linux/node_linux_test.go
+++ b/pkg/datapath/linux/node_linux_test.go
@@ -1067,11 +1067,15 @@ func (s *linuxPrivilegedIPv6OnlyTestSuite) TestArpPingHandling(c *check.C) {
 	c.Assert(err, check.IsNil)
 
 	// wait waits for neigh entry update or waits for removal if waitForDelete=true
-	wait := func(nodeID nodeTypes.Identity, before *time.Time, waitForDelete bool) {
+	wait := func(nodeID nodeTypes.Identity, link string, before *time.Time, waitForDelete bool) {
 		err := testutils.WaitUntil(func() bool {
 			linuxNodeHandler.neighLock.Lock()
 			defer linuxNodeHandler.neighLock.Unlock()
-			nextHop, found := linuxNodeHandler.neighNextHopByNode6[nodeID]
+			nextHopByLink, found := linuxNodeHandler.neighNextHopByNode6[nodeID]
+			if !found {
+				return waitForDelete
+			}
+			nextHop, found := nextHopByLink[link]
 			if !found {
 				return waitForDelete
 			}
@@ -1101,7 +1105,7 @@ func (s *linuxPrivilegedIPv6OnlyTestSuite) TestArpPingHandling(c *check.C) {
 	err = linuxNodeHandler.NodeAdd(nodev1)
 	c.Assert(err, check.IsNil)
 	// insertNeighbor is invoked async, so thus this wait based on last ping
-	wait(nodev1.Identity(), &now, false)
+	wait(nodev1.Identity(), "veth0", &now, false)
 refetch1:
 	// Check whether an arp entry for nodev1 IP addr (=veth1) was added
 	neighs, err := netlink.NeighList(veth0.Attrs().Index, netlink.FAMILY_V6)
@@ -1139,7 +1143,7 @@ refetch1:
 	c.Assert(err, check.IsNil)
 
 	linuxNodeHandler.NodeNeighborRefresh(context.TODO(), nodev1)
-	wait(nodev1.Identity(), &now, false)
+	wait(nodev1.Identity(), "veth0", &now, false)
 refetch2:
 	neighs, err = netlink.NeighList(veth0.Attrs().Index, netlink.FAMILY_V6)
 	c.Assert(err, check.IsNil)
@@ -1164,7 +1168,7 @@ refetch2:
 	err = linuxNodeHandler.NodeDelete(nodev1)
 	c.Assert(err, check.IsNil)
 	// deleteNeighbor is invoked async too
-	wait(nodev1.Identity(), nil, true)
+	wait(nodev1.Identity(), "veth0", nil, true)
 
 	neighs, err = netlink.NeighList(veth0.Attrs().Index, netlink.FAMILY_V6)
 	c.Assert(err, check.IsNil)
@@ -1183,7 +1187,7 @@ refetch2:
 	now = time.Now()
 	err = linuxNodeHandler.NodeAdd(nodev1)
 	c.Assert(err, check.IsNil)
-	wait(nodev1.Identity(), &now, false)
+	wait(nodev1.Identity(), "veth0", &now, false)
 
 	rndHWAddr := func() net.HardwareAddr {
 		mac := make([]byte, 6)
@@ -1253,7 +1257,7 @@ refetch2:
 	now = time.Now()
 	err = linuxNodeHandler.NodeDelete(nodev1)
 	c.Assert(err, check.IsNil)
-	wait(nodev1.Identity(), nil, true)
+	wait(nodev1.Identity(), "veth0", nil, true)
 
 	// Setup routine for the 2. test
 	setupRemoteNode := func(vethName, vethPeerName, netnsName, vethCIDR, vethIPAddr,
@@ -1400,7 +1404,7 @@ refetch2:
 	}
 	now = time.Now()
 	c.Assert(linuxNodeHandler.NodeAdd(nodev2), check.IsNil)
-	wait(nodev2.Identity(), &now, false)
+	wait(nodev2.Identity(), "veth0", &now, false)
 
 	node3IP := net.ParseIP("f00b::250")
 	nodev3 := nodeTypes.Node{
@@ -1408,7 +1412,7 @@ refetch2:
 		IPAddresses: []nodeTypes.Address{{nodeaddressing.NodeInternalIP, node3IP}},
 	}
 	c.Assert(linuxNodeHandler.NodeAdd(nodev3), check.IsNil)
-	wait(nodev3.Identity(), &now, false)
+	wait(nodev3.Identity(), "veth0", &now, false)
 
 	nextHop := net.ParseIP("f00d::250")
 refetch3:
@@ -1434,7 +1438,7 @@ refetch3:
 
 	// Check that removing node2 will not remove nextHop, as it is still used by node3
 	c.Assert(linuxNodeHandler.NodeDelete(nodev2), check.IsNil)
-	wait(nodev2.Identity(), nil, true)
+	wait(nodev2.Identity(), "veth0", nil, true)
 	neighs, err = netlink.NeighList(veth0.Attrs().Index, netlink.FAMILY_V6)
 	found = false
 	for _, n := range neighs {
@@ -1447,7 +1451,7 @@ refetch3:
 
 	// However, removing node3 should remove the neigh entry for nextHop
 	c.Assert(linuxNodeHandler.NodeDelete(nodev3), check.IsNil)
-	wait(nodev3.Identity(), nil, true)
+	wait(nodev3.Identity(), "veth0", nil, true)
 
 	found = false
 	neighs, err = netlink.NeighList(veth0.Attrs().Index, netlink.FAMILY_V6)
@@ -1462,7 +1466,7 @@ refetch3:
 
 	now = time.Now()
 	c.Assert(linuxNodeHandler.NodeAdd(nodev3), check.IsNil)
-	wait(nodev3.Identity(), &now, false)
+	wait(nodev3.Identity(), "veth0", &now, false)
 
 	nextHop = net.ParseIP("f00d::250")
 refetch4:
@@ -1530,11 +1534,11 @@ refetch5:
 	// deleted from the neighbor table as well as the new one added.
 	now = time.Now()
 	c.Assert(linuxNodeHandler.NodeAdd(nodev2), check.IsNil)
-	wait(nodev2.Identity(), &now, false)
+	wait(nodev2.Identity(), "veth0", &now, false)
 
 	now = time.Now()
 	c.Assert(linuxNodeHandler.NodeAdd(nodev3), check.IsNil)
-	wait(nodev3.Identity(), &now, false)
+	wait(nodev3.Identity(), "veth0", &now, false)
 
 	nextHop = net.ParseIP("f00d::250")
 refetch6:
@@ -1563,11 +1567,15 @@ refetch6:
 	c.Assert(err, check.IsNil)
 
 	// waitGw waits for the nextHop to appear in the agent's nextHop table
-	waitGw := func(nextHopNew string, nodeID nodeTypes.Identity, before *time.Time) {
+	waitGw := func(nextHopNew string, nodeID nodeTypes.Identity, link string, before *time.Time) {
 		err := testutils.WaitUntil(func() bool {
 			linuxNodeHandler.neighLock.Lock()
 			defer linuxNodeHandler.neighLock.Unlock()
-			nextHop, found := linuxNodeHandler.neighNextHopByNode6[nodeID]
+			nextHopByLink, found := linuxNodeHandler.neighNextHopByNode6[nodeID]
+			if !found {
+				return false
+			}
+			nextHop, found := nextHopByLink[link]
 			if !found {
 				return false
 			}
@@ -1587,8 +1595,8 @@ refetch6:
 	now = time.Now()
 	linuxNodeHandler.NodeNeighborRefresh(context.Background(), nodev2)
 	linuxNodeHandler.NodeNeighborRefresh(context.Background(), nodev3)
-	waitGw("f00d::251", nodev2.Identity(), &now)
-	waitGw("f00d::250", nodev3.Identity(), &now)
+	waitGw("f00d::251", nodev2.Identity(), "veth0", &now)
+	waitGw("f00d::250", nodev3.Identity(), "veth0", &now)
 
 	// Both nextHops now need to be present
 	nextHop = net.ParseIP("f00d::250")
@@ -1641,8 +1649,8 @@ refetch8:
 	now = time.Now()
 	linuxNodeHandler.NodeNeighborRefresh(context.Background(), nodev2)
 	linuxNodeHandler.NodeNeighborRefresh(context.Background(), nodev3)
-	waitGw("f00d::251", nodev2.Identity(), &now)
-	waitGw("f00d::251", nodev3.Identity(), &now)
+	waitGw("f00d::251", nodev2.Identity(), "veth0", &now)
+	waitGw("f00d::251", nodev3.Identity(), "veth0", &now)
 
 	nextHop = net.ParseIP("f00d::250")
 refetch9:
@@ -1689,7 +1697,7 @@ refetch10:
 	c.Assert(found, check.Equals, true)
 
 	c.Assert(linuxNodeHandler.NodeDelete(nodev3), check.IsNil)
-	wait(nodev3.Identity(), nil, true)
+	wait(nodev3.Identity(), "veth0", nil, true)
 
 	// In the next test, we have node2 left in the neighbor table, and
 	// we add an unrelated externally learned neighbor entry. Check that
@@ -1758,12 +1766,12 @@ refetch11:
 	c.Assert(found, check.Equals, true)
 
 	c.Assert(linuxNodeHandler.NodeDelete(nodev2), check.IsNil)
-	wait(nodev2.Identity(), nil, true)
+	wait(nodev2.Identity(), "veth0", nil, true)
 
 	linuxNodeHandler.NodeCleanNeighborsLink(veth0, false)
 }
 
-func (s *linuxPrivilegedIPv4OnlyTestSuite) TestArpPingHandling(c *check.C) {
+func (s *linuxPrivilegedIPv6OnlyTestSuite) TestArpPingHandlingForMultiDevice(c *check.C) {
 	runtime.LockOSThread()
 	defer runtime.UnlockOSThread()
 
@@ -1778,39 +1786,46 @@ func (s *linuxPrivilegedIPv4OnlyTestSuite) TestArpPingHandling(c *check.C) {
 	tmpDir := c.MkDir()
 	option.Config.StateDir = tmpDir
 
-	baseTimeOld, err := sysctl.Read(baseIPv4Time)
+	baseTimeOld, err := sysctl.Read(baseIPv6Time)
 	c.Assert(err, check.IsNil)
-	err = sysctl.Write(baseIPv4Time, fmt.Sprintf("%d", 2500))
+	err = sysctl.Write(baseIPv6Time, fmt.Sprintf("%d", 2500))
 	c.Assert(err, check.IsNil)
-	defer func() { sysctl.Write(baseIPv4Time, baseTimeOld) }()
+	defer func() { sysctl.Write(baseIPv6Time, baseTimeOld) }()
 
 	// 1. Test whether another node in the same L2 subnet can be arpinged.
-	//    The other node is in the different netns reachable via the veth pair.
+	//    Each node has two devices and the other node in the different netns
+	//    is reachable via either pair.
 	//
 	//      +--------------+     +--------------+
-	//      |  host netns  |     |    netns0    |
+	//      |  host netns  |     |    netns1    |
 	//      |              |     |    nodev1    |
+	//      |              |     |  fe80::1/128 |
 	//      |         veth0+-----+veth1         |
-	//      | 9.9.9.249/29 |     | 9.9.9.250/29 |
+	//      |          |   |     |   |          |
+	//      | f00d::249/96 |     | f00d::250/96 |
+	//      |              |     |              |
+	//      |         veth2+-----+veth3         |
+	//      |          |   |     | |            |
+	//      | f00a::249/96 |     | f00a::250/96 |
 	//      +--------------+     +--------------+
 
 	// Setup
-	veth := &netlink.Veth{
+	vethPair01 := &netlink.Veth{
 		LinkAttrs: netlink.LinkAttrs{Name: "veth0"},
 		PeerName:  "veth1",
 	}
-	err = netlink.LinkAdd(veth)
+	err = netlink.LinkAdd(vethPair01)
 	c.Assert(err, check.IsNil)
-	defer netlink.LinkDel(veth)
+	defer netlink.LinkDel(vethPair01)
 	veth0, err := netlink.LinkByName("veth0")
 	c.Assert(err, check.IsNil)
 	veth1, err := netlink.LinkByName("veth1")
 	c.Assert(err, check.IsNil)
-	_, ipnet, err := net.ParseCIDR("9.9.9.252/29")
-	ip0 := net.ParseIP("9.9.9.249")
-	ip1 := net.ParseIP("9.9.9.250")
-	ipG := net.ParseIP("9.9.9.251")
-	ipnet.IP = ip0
+	_, ipnet, err := net.ParseCIDR("f00d::/96")
+	v1IP0 := net.ParseIP("f00d::249")
+	v1IP1 := net.ParseIP("f00d::250")
+	v1IPG := net.ParseIP("f00d::251")
+	ipnet.IP = v1IP0
 	addr := &netlink.Addr{IPNet: ipnet}
 	err = netlink.AddrAdd(veth0, addr)
 	c.Assert(err, check.IsNil)
@@ -1823,31 +1838,104 @@ func (s *linuxPrivilegedIPv4OnlyTestSuite) TestArpPingHandling(c *check.C) {
 	err = netlink.LinkSetNsFd(veth1, int(netns0.Fd()))
 	c.Assert(err, check.IsNil)
 	netns0.Do(func(ns.NetNS) error {
+		lo, err := netlink.LinkByName("lo")
+		c.Assert(err, check.IsNil)
+		err = netlink.LinkSetUp(lo)
+		c.Assert(err, check.IsNil)
+		addr, err := netlink.ParseAddr("fe80::1/128")
+		c.Assert(err, check.IsNil)
+		err = netlink.AddrAdd(lo, addr)
+		c.Assert(err, check.IsNil)
+
 		veth1, err := netlink.LinkByName("veth1")
 		c.Assert(err, check.IsNil)
-		ipnet.IP = ip1
+		ipnet.IP = v1IP1
 		addr = &netlink.Addr{IPNet: ipnet}
-		netlink.AddrAdd(veth1, addr)
+		err = netlink.AddrAdd(veth1, addr)
 		c.Assert(err, check.IsNil)
-		ipnet.IP = ipG
+		ipnet.IP = v1IPG
 		addr = &netlink.Addr{IPNet: ipnet}
-		netlink.AddrAdd(veth1, addr)
+		err = netlink.AddrAdd(veth1, addr)
 		c.Assert(err, check.IsNil)
 		err = netlink.LinkSetUp(veth1)
 		c.Assert(err, check.IsNil)
 		return nil
 	})
 
+	vethPair23 := &netlink.Veth{
+		LinkAttrs: netlink.LinkAttrs{Name: "veth2"},
+		PeerName:  "veth3",
+	}
+	err = netlink.LinkAdd(vethPair23)
+	c.Assert(err, check.IsNil)
+	defer netlink.LinkDel(vethPair23)
+	veth2, err := netlink.LinkByName("veth2")
+	c.Assert(err, check.IsNil)
+	veth3, err := netlink.LinkByName("veth3")
+	c.Assert(err, check.IsNil)
+	_, ipnet, err = net.ParseCIDR("f00a::/96")
+	v2IP0 := net.ParseIP("f00a::249")
+	v2IP1 := net.ParseIP("f00a::250")
+	v2IPG := net.ParseIP("f00a::251")
+	ipnet.IP = v2IP0
+	addr = &netlink.Addr{IPNet: ipnet}
+	err = netlink.AddrAdd(veth2, addr)
+	c.Assert(err, check.IsNil)
+	err = netlink.LinkSetUp(veth2)
+	c.Assert(err, check.IsNil)
+
+	err = netlink.LinkSetNsFd(veth3, int(netns0.Fd()))
+	c.Assert(err, check.IsNil)
+	err = netns0.Do(func(ns.NetNS) error {
+		veth3, err := netlink.LinkByName("veth3")
+		c.Assert(err, check.IsNil)
+		ipnet.IP = v2IP1
+		addr = &netlink.Addr{IPNet: ipnet}
+		err = netlink.AddrAdd(veth3, addr)
+		c.Assert(err, check.IsNil)
+		ipnet.IP = v2IPG
+		addr = &netlink.Addr{IPNet: ipnet}
+		err = netlink.AddrAdd(veth3, addr)
+		c.Assert(err, check.IsNil)
+		err = netlink.LinkSetUp(veth3)
+		c.Assert(err, check.IsNil)
+		return nil
+	})
+	c.Assert(err, check.IsNil)
+
+	r := &netlink.Route{
+		Dst: netlink.NewIPNet(net.ParseIP("fe80::1")),
+		MultiPath: []*netlink.NexthopInfo{
+			{
+				LinkIndex: veth0.Attrs().Index,
+				Gw:        v1IP1,
+			},
+			{
+				LinkIndex: veth2.Attrs().Index,
+				Gw:        v2IP1,
+			},
+		}}
+
+	err = netlink.RouteAdd(r)
+	c.Assert(err, check.IsNil)
+	defer netlink.RouteDel(r)
+
+	prevTunnel := option.Config.Tunnel
+	defer func() { option.Config.Tunnel = prevTunnel }()
+	option.Config.Tunnel = option.TunnelDisabled
 	prevDRDev := option.Config.DirectRoutingDevice
 	defer func() { option.Config.DirectRoutingDevice = prevDRDev }()
 	option.Config.DirectRoutingDevice = "veth0"
+	prevDevices := option.Config.Devices
+	defer func() { option.Config.Devices = prevDevices }()
+	option.Config.Devices = []string{"veth0", "veth2"}
 	prevNP := option.Config.EnableNodePort
 	defer func() { option.Config.EnableNodePort = prevNP }()
 	option.Config.EnableNodePort = true
 	dpConfig := DatapathConfiguration{HostDevice: "veth0"}
 	prevARPPeriod := option.Config.ARPPingRefreshPeriod
 	defer func() { option.Config.ARPPingRefreshPeriod = prevARPPeriod }()
-	option.Config.ARPPingRefreshPeriod = time.Duration(1 * time.Nanosecond)
+	option.Config.ARPPingRefreshPeriod = 1 * time.Nanosecond
 
 	linuxNodeHandler := NewNodeHandler(dpConfig, s.nodeAddressing, nil).(*linuxNodeHandler)
 	c.Assert(linuxNodeHandler, check.Not(check.IsNil))
@@ -1860,11 +1948,15 @@ func (s *linuxPrivilegedIPv4OnlyTestSuite) TestArpPingHandling(c *check.C) {
 	c.Assert(err, check.IsNil)
 
 	// wait waits for neigh entry update or waits for removal if waitForDelete=true
-	wait := func(nodeID nodeTypes.Identity, before *time.Time, waitForDelete bool) {
+	wait := func(nodeID nodeTypes.Identity, link string, before *time.Time, waitForDelete bool) {
 		err := testutils.WaitUntil(func() bool {
 			linuxNodeHandler.neighLock.Lock()
 			defer linuxNodeHandler.neighLock.Unlock()
-			nextHop, found := linuxNodeHandler.neighNextHopByNode4[nodeID]
+			nextHopByLink, found := linuxNodeHandler.neighNextHopByNode6[nodeID]
+			if !found {
+				return waitForDelete
+			}
+			nextHop, found := nextHopByLink[link]
 			if !found {
 				return waitForDelete
 			}
@@ -1882,7 +1974,7 @@ func (s *linuxPrivilegedIPv4OnlyTestSuite) TestArpPingHandling(c *check.C) {
 
 	nodev1 := nodeTypes.Node{
 		Name:        "node1",
-		IPAddresses: []nodeTypes.Address{{nodeaddressing.NodeInternalIP, ip1}},
+		IPAddresses: []nodeTypes.Address{{nodeaddressing.NodeInternalIP, net.ParseIP("fe80::1")}},
 	}
 	now := time.Now()
 	err = linuxNodeHandler.NodeAdd(nodev1)
@@ -1894,14 +1986,15 @@ func (s *linuxPrivilegedIPv4OnlyTestSuite) TestArpPingHandling(c *check.C) {
 	err = linuxNodeHandler.NodeAdd(nodev1)
 	c.Assert(err, check.IsNil)
 	// insertNeighbor is invoked async, so thus this wait based on last ping
-	wait(nodev1.Identity(), &now, false)
+	wait(nodev1.Identity(), "veth0", &now, false)
+	wait(nodev1.Identity(), "veth2", &now, false)
 refetch1:
 	// Check whether an arp entry for nodev1 IP addr (=veth1) was added
-	neighs, err := netlink.NeighList(veth0.Attrs().Index, netlink.FAMILY_V4)
+	neighs, err := netlink.NeighList(veth0.Attrs().Index, netlink.FAMILY_V6)
 	c.Assert(err, check.IsNil)
 	found := false
 	for _, n := range neighs {
-		if n.IP.Equal(ip1) {
+		if n.IP.Equal(v1IP1) {
 			good, retry := neighStateOk(n)
 			if good {
 				found = true
@@ -1914,31 +2007,61 @@ refetch1:
 	}
 	c.Assert(found, check.Equals, true)
 
-	// Swap MAC addresses of veth0 and veth1 to ensure the MAC address of veth1 changed.
+refetch2:
+	// Check whether an arp entry for nodev1 IP addr (=veth3) was added
+	neighs, err = netlink.NeighList(veth2.Attrs().Index, netlink.FAMILY_V6)
+	c.Assert(err, check.IsNil)
+	found = false
+	for _, n := range neighs {
+		if n.IP.Equal(v2IP1) {
+			good, retry := neighStateOk(n)
+			if good {
+				found = true
+				break
+			}
+			if retry {
+				goto refetch2
+			}
+		}
+	}
+	c.Assert(found, check.Equals, true)
+
+	// Swap MAC addresses of veth0 and veth1, veth2 and veth3 to ensure the MAC address of veth1 changed.
 	// Trigger neighbor refresh on veth0 and check whether the arp entry was updated.
-	var veth0HwAddr, veth1HwAddr, updatedHwAddrFromArpEntry net.HardwareAddr
+	var veth0HwAddr, veth1HwAddr, veth2HwAddr, veth3HwAddr, updatedHwAddrFromArpEntry net.HardwareAddr
 	veth0HwAddr = veth0.Attrs().HardwareAddr
-	netns0.Do(func(ns.NetNS) error {
+	veth2HwAddr = veth2.Attrs().HardwareAddr
+	err = netns0.Do(func(ns.NetNS) error {
 		veth1, err := netlink.LinkByName("veth1")
 		c.Assert(err, check.IsNil)
 		veth1HwAddr = veth1.Attrs().HardwareAddr
 		err = netlink.LinkSetHardwareAddr(veth1, veth0HwAddr)
 		c.Assert(err, check.IsNil)
+
+		veth3, err := netlink.LinkByName("veth3")
+		c.Assert(err, check.IsNil)
+		veth3HwAddr = veth3.Attrs().HardwareAddr
+		err = netlink.LinkSetHardwareAddr(veth3, veth2HwAddr)
+		c.Assert(err, check.IsNil)
 		return nil
 	})
+	c.Assert(err, check.IsNil)
 
 	now = time.Now()
 	err = netlink.LinkSetHardwareAddr(veth0, veth1HwAddr)
 	c.Assert(err, check.IsNil)
+	err = netlink.LinkSetHardwareAddr(veth2, veth3HwAddr)
+	c.Assert(err, check.IsNil)
 
 	linuxNodeHandler.NodeNeighborRefresh(context.TODO(), nodev1)
-	wait(nodev1.Identity(), &now, false)
-refetch2:
-	neighs, err = netlink.NeighList(veth0.Attrs().Index, netlink.FAMILY_V4)
+	wait(nodev1.Identity(), "veth0", &now, false)
+	wait(nodev1.Identity(), "veth2", &now, false)
+refetch3:
+	neighs, err = netlink.NeighList(veth0.Attrs().Index, netlink.FAMILY_V6)
 	c.Assert(err, check.IsNil)
 	found = false
 	for _, n := range neighs {
-		if n.IP.Equal(ip1) {
+		if n.IP.Equal(v1IP1) {
 			good, retry := neighStateOk(n)
 			if good {
 				found = true
@@ -1946,160 +2069,407 @@ refetch2:
 				break
 			}
 			if retry {
-				goto refetch2
+				goto refetch3
 			}
 		}
 	}
 	c.Assert(found, check.Equals, true)
 	c.Assert(updatedHwAddrFromArpEntry.String(), check.Equals, veth0HwAddr.String())
 
+refetch4:
+	neighs, err = netlink.NeighList(veth2.Attrs().Index, netlink.FAMILY_V6)
+	c.Assert(err, check.IsNil)
+	found = false
+	for _, n := range neighs {
+		if n.IP.Equal(v2IP1) {
+			good, retry := neighStateOk(n)
+			if good {
+				found = true
+				updatedHwAddrFromArpEntry = n.HardwareAddr
+				break
+			}
+			if retry {
+				goto refetch4
+			}
+		}
+	}
+	c.Assert(found, check.Equals, true)
+	c.Assert(updatedHwAddrFromArpEntry.String(), check.Equals, veth2HwAddr.String())
+
 	// Remove nodev1, and check whether the arp entry was removed
 	err = linuxNodeHandler.NodeDelete(nodev1)
 	c.Assert(err, check.IsNil)
 	// deleteNeighbor is invoked async too
-	wait(nodev1.Identity(), nil, true)
+	wait(nodev1.Identity(), "veth0", nil, true)
+	wait(nodev1.Identity(), "veth2", nil, true)
 
-	neighs, err = netlink.NeighList(veth0.Attrs().Index, netlink.FAMILY_V4)
+	neighs, err = netlink.NeighList(veth0.Attrs().Index, netlink.FAMILY_V6)
 	c.Assert(err, check.IsNil)
 	found = false
 	for _, n := range neighs {
-		if n.IP.Equal(ip1) {
+		if n.IP.Equal(v1IP1) {
 			found = true
 			break
 		}
 	}
 	c.Assert(found, check.Equals, false)
 
-	// Create multiple goroutines which call insertNeighbor and check whether
-	// MAC changes of veth1 are properly handled. This is a basic randomized
-	// testing of insertNeighbor() fine-grained locking.
-	now = time.Now()
-	err = linuxNodeHandler.NodeAdd(nodev1)
+	neighs, err = netlink.NeighList(veth2.Attrs().Index, netlink.FAMILY_V6)
 	c.Assert(err, check.IsNil)
-	wait(nodev1.Identity(), &now, false)
-
-	rndHWAddr := func() net.HardwareAddr {
-		mac := make([]byte, 6)
-		_, err := rand.Read(mac)
-		c.Assert(err, check.IsNil)
-		mac[0] = (mac[0] | 2) & 0xfe
-		return net.HardwareAddr(mac)
-	}
-	neighRefCount := func(nextHopStr string) int {
-		linuxNodeHandler.neighLock.Lock()
-		defer linuxNodeHandler.neighLock.Unlock()
-		return linuxNodeHandler.neighNextHopRefCount[nextHopStr]
-	}
-
-	done := make(chan struct{})
-	count := 30
-	var wg sync.WaitGroup
-	wg.Add(count)
-	for i := 0; i < count; i++ {
-		go func() {
-			defer wg.Done()
-			ticker := time.NewTicker(100 * time.Millisecond)
-			for {
-				linuxNodeHandler.insertNeighbor(context.Background(), &nodev1, true)
-				select {
-				case <-ticker.C:
-				case <-done:
-					return
-				}
-			}
-		}()
+	found = false
+	for _, n := range neighs {
+		if n.IP.Equal(v2IP1) {
+			found = true
+			break
+		}
 	}
-	for i := 0; i < 10; i++ {
-		mac := rndHWAddr()
-		// Change MAC
-		netns0.Do(func(ns.NetNS) error {
-			veth1, err := netlink.LinkByName("veth1")
-			c.Assert(err, check.IsNil)
-			err = netlink.LinkSetHardwareAddr(veth1, mac)
-			c.Assert(err, check.IsNil)
-			return nil
-		})
+	c.Assert(found, check.Equals, false)
+}
 
-		// Check that MAC has been changed in the neigh table
-		var found bool
-		err := testutils.WaitUntilWithSleep(func() bool {
-			neighs, err = netlink.NeighList(veth0.Attrs().Index, netlink.FAMILY_V4)
-			c.Assert(err, check.IsNil)
-			found = false
-			for _, n := range neighs {
-				if n.IP.Equal(ip1) && (n.State&netlink.NUD_REACHABLE) > 0 &&
-					n.HardwareAddr.String() == mac.String() &&
-					neighRefCount(ip1.String()) == 1 {
-					found = true
-					return true
-				}
-			}
-			return false
-		}, 25*time.Second, 200*time.Millisecond)
-		c.Assert(err, check.IsNil)
-		c.Assert(found, check.Equals, true)
-	}
+func (s *linuxPrivilegedIPv4OnlyTestSuite) TestArpPingHandling(c *check.C) {
+	runtime.LockOSThread()
+	defer runtime.UnlockOSThread()
 
-	// Cleanup
-	close(done)
-	wg.Wait()
-	now = time.Now()
-	err = linuxNodeHandler.NodeDelete(nodev1)
-	c.Assert(err, check.IsNil)
-	wait(nodev1.Identity(), nil, true)
+	prevEnableL2NeighDiscovery := option.Config.EnableL2NeighDiscovery
+	defer func() { option.Config.EnableL2NeighDiscovery = prevEnableL2NeighDiscovery }()
 
-	// Setup routine for the 2. test
-	setupRemoteNode := func(vethName, vethPeerName, netnsName, vethCIDR, vethIPAddr,
-		vethPeerIPAddr string) (cleanup func(), errRet error) {
+	option.Config.EnableL2NeighDiscovery = true
 
-		veth := &netlink.Veth{
-			LinkAttrs: netlink.LinkAttrs{Name: vethName},
-			PeerName:  vethPeerName,
-		}
-		errRet = netlink.LinkAdd(veth)
-		if errRet != nil {
-			return nil, err
-		}
-		cleanup1 := func() { netlink.LinkDel(veth) }
-		cleanup = cleanup1
+	prevStateDir := option.Config.StateDir
+	defer func() { option.Config.StateDir = prevStateDir }()
 
-		veth2, err := netlink.LinkByName(vethName)
-		if err != nil {
-			errRet = err
-			return
-		}
-		veth3, err := netlink.LinkByName(vethPeerName)
-		if err != nil {
-			errRet = err
-			return
-		}
-		netns1, err := netns.ReplaceNetNSWithName(netnsName)
-		if err != nil {
-			errRet = err
-			return
-		}
-		cleanup = func() {
-			cleanup1()
-			netns1.Close()
-		}
-		if errRet = netlink.LinkSetNsFd(veth2, int(netns0.Fd())); errRet != nil {
-			return
-		}
-		if errRet = netlink.LinkSetNsFd(veth3, int(netns1.Fd())); errRet != nil {
-			return
-		}
+	tmpDir := c.MkDir()
+	option.Config.StateDir = tmpDir
 
-		ip, ipnet, err := net.ParseCIDR(vethCIDR)
-		if err != nil {
-			errRet = err
-			return
-		}
-		ip2 := net.ParseIP(vethIPAddr)
-		ip3 := net.ParseIP(vethPeerIPAddr)
-		ipnet.IP = ip2
+	baseTimeOld, err := sysctl.Read(baseIPv4Time)
+	c.Assert(err, check.IsNil)
+	err = sysctl.Write(baseIPv4Time, fmt.Sprintf("%d", 2500))
+	c.Assert(err, check.IsNil)
+	defer func() { sysctl.Write(baseIPv4Time, baseTimeOld) }()
 
-		if errRet = netns0.Do(func(ns.NetNS) error {
-			addr = &netlink.Addr{IPNet: ipnet}
+	// 1. Test whether another node in the same L2 subnet can be arpinged.
+	//    The other node is in the different netns reachable via the veth pair.
+	//
+	//      +--------------+     +--------------+
+	//      |  host netns  |     |    netns0    |
+	//      |              |     |    nodev1    |
+	//      |         veth0+-----+veth1         |
+	//      | 9.9.9.249/29 |     | 9.9.9.250/29 |
+	//      +--------------+     +--------------+
+
+	// Setup
+	veth := &netlink.Veth{
+		LinkAttrs: netlink.LinkAttrs{Name: "veth0"},
+		PeerName:  "veth1",
+	}
+	err = netlink.LinkAdd(veth)
+	c.Assert(err, check.IsNil)
+	defer netlink.LinkDel(veth)
+	veth0, err := netlink.LinkByName("veth0")
+	c.Assert(err, check.IsNil)
+	veth1, err := netlink.LinkByName("veth1")
+	c.Assert(err, check.IsNil)
+	_, ipnet, err := net.ParseCIDR("9.9.9.252/29")
+	ip0 := net.ParseIP("9.9.9.249")
+	ip1 := net.ParseIP("9.9.9.250")
+	ipG := net.ParseIP("9.9.9.251")
+	ipnet.IP = ip0
+	addr := &netlink.Addr{IPNet: ipnet}
+	err = netlink.AddrAdd(veth0, addr)
+	c.Assert(err, check.IsNil)
+	err = netlink.LinkSetUp(veth0)
+	c.Assert(err, check.IsNil)
+
+	netns0, err := netns.ReplaceNetNSWithName("test-arping-netns0")
+	c.Assert(err, check.IsNil)
+	defer netns0.Close()
+	err = netlink.LinkSetNsFd(veth1, int(netns0.Fd()))
+	c.Assert(err, check.IsNil)
+	netns0.Do(func(ns.NetNS) error {
+		veth1, err := netlink.LinkByName("veth1")
+		c.Assert(err, check.IsNil)
+		ipnet.IP = ip1
+		addr = &netlink.Addr{IPNet: ipnet}
+		netlink.AddrAdd(veth1, addr)
+		c.Assert(err, check.IsNil)
+		ipnet.IP = ipG
+		addr = &netlink.Addr{IPNet: ipnet}
+		netlink.AddrAdd(veth1, addr)
+		c.Assert(err, check.IsNil)
+		err = netlink.LinkSetUp(veth1)
+		c.Assert(err, check.IsNil)
+		return nil
+	})
+
+	prevTunnel := option.Config.Tunnel
+	defer func() { option.Config.Tunnel = prevTunnel }()
+	option.Config.Tunnel = option.TunnelDisabled
+	prevDRDev := option.Config.DirectRoutingDevice
+	defer func() { option.Config.DirectRoutingDevice = prevDRDev }()
+	option.Config.DirectRoutingDevice = "veth0"
+	prevNP := option.Config.EnableNodePort
+	defer func() { option.Config.EnableNodePort = prevNP }()
+	option.Config.EnableNodePort = true
+	dpConfig := DatapathConfiguration{HostDevice: "veth0"}
+	prevARPPeriod := option.Config.ARPPingRefreshPeriod
+	defer func() { option.Config.ARPPingRefreshPeriod = prevARPPeriod }()
+	option.Config.ARPPingRefreshPeriod = time.Duration(1 * time.Nanosecond)
+
+	linuxNodeHandler := NewNodeHandler(dpConfig, s.nodeAddressing, nil).(*linuxNodeHandler)
+	c.Assert(linuxNodeHandler, check.Not(check.IsNil))
+
+	err = linuxNodeHandler.NodeConfigurationChanged(datapath.LocalNodeConfiguration{
+		EnableEncapsulation: false,
+		EnableIPv4:          s.enableIPv4,
+		EnableIPv6:          s.enableIPv6,
+	})
+	c.Assert(err, check.IsNil)
+
+	// wait waits for neigh entry update or waits for removal if waitForDelete=true
+	wait := func(nodeID nodeTypes.Identity, link string, before *time.Time, waitForDelete bool) {
+		err := testutils.WaitUntil(func() bool {
+			linuxNodeHandler.neighLock.Lock()
+			defer linuxNodeHandler.neighLock.Unlock()
+			nextHopByLink, found := linuxNodeHandler.neighNextHopByNode4[nodeID]
+			if !found {
+				return waitForDelete
+			}
+			nextHop, found := nextHopByLink[link]
+			if !found {
+				return waitForDelete
+			}
+			lastPing, found := linuxNodeHandler.neighLastPingByNextHop[nextHop]
+			if !found {
+				return false
+			}
+			if waitForDelete {
+				return false
+			}
+			return before.Before(lastPing)
+		}, 5*time.Second)
+		c.Assert(err, check.IsNil)
+	}
+
+	nodev1 := nodeTypes.Node{
+		Name:        "node1",
+		IPAddresses: []nodeTypes.Address{{nodeaddressing.NodeInternalIP, ip1}},
+	}
+	now := time.Now()
+	err = linuxNodeHandler.NodeAdd(nodev1)
+	c.Assert(err, check.IsNil)
+	// insertNeighbor is invoked async
+	// Insert the same node second time. This should not increment refcount for
+	// the same nextHop. We test it by checking that NodeDelete has removed the
+	// related neigh entry.
+	err = linuxNodeHandler.NodeAdd(nodev1)
+	c.Assert(err, check.IsNil)
+	// insertNeighbor is invoked async, so thus this wait based on last ping
+	wait(nodev1.Identity(), "veth0", &now, false)
+refetch1:
+	// Check whether an arp entry for nodev1 IP addr (=veth1) was added
+	neighs, err := netlink.NeighList(veth0.Attrs().Index, netlink.FAMILY_V4)
+	c.Assert(err, check.IsNil)
+	found := false
+	for _, n := range neighs {
+		if n.IP.Equal(ip1) {
+			good, retry := neighStateOk(n)
+			if good {
+				found = true
+				break
+			}
+			if retry {
+				goto refetch1
+			}
+		}
+	}
+	c.Assert(found, check.Equals, true)
+
+	// Swap MAC addresses of veth0 and veth1 to ensure the MAC address of veth1 changed.
+	// Trigger neighbor refresh on veth0 and check whether the arp entry was updated.
+	var veth0HwAddr, veth1HwAddr, updatedHwAddrFromArpEntry net.HardwareAddr
+	veth0HwAddr = veth0.Attrs().HardwareAddr
+	netns0.Do(func(ns.NetNS) error {
+		veth1, err := netlink.LinkByName("veth1")
+		c.Assert(err, check.IsNil)
+		veth1HwAddr = veth1.Attrs().HardwareAddr
+		err = netlink.LinkSetHardwareAddr(veth1, veth0HwAddr)
+		c.Assert(err, check.IsNil)
+		return nil
+	})
+
+	now = time.Now()
+	err = netlink.LinkSetHardwareAddr(veth0, veth1HwAddr)
+	c.Assert(err, check.IsNil)
+
+	linuxNodeHandler.NodeNeighborRefresh(context.TODO(), nodev1)
+	wait(nodev1.Identity(), "veth0", &now, false)
+refetch2:
+	neighs, err = netlink.NeighList(veth0.Attrs().Index, netlink.FAMILY_V4)
+	c.Assert(err, check.IsNil)
+	found = false
+	for _, n := range neighs {
+		if n.IP.Equal(ip1) {
+			good, retry := neighStateOk(n)
+			if good {
+				found = true
+				updatedHwAddrFromArpEntry = n.HardwareAddr
+				break
+			}
+			if retry {
+				goto refetch2
+			}
+		}
+	}
+	c.Assert(found, check.Equals, true)
+	c.Assert(updatedHwAddrFromArpEntry.String(), check.Equals, veth0HwAddr.String())
+
+	// Remove nodev1, and check whether the arp entry was removed
+	err = linuxNodeHandler.NodeDelete(nodev1)
+	c.Assert(err, check.IsNil)
+	// deleteNeighbor is invoked async too
+	wait(nodev1.Identity(), "veth0", nil, true)
+
+	neighs, err = netlink.NeighList(veth0.Attrs().Index, netlink.FAMILY_V4)
+	c.Assert(err, check.IsNil)
+	found = false
+	for _, n := range neighs {
+		if n.IP.Equal(ip1) {
+			found = true
+			break
+		}
+	}
+	c.Assert(found, check.Equals, false)
+
+	// Create multiple goroutines which call insertNeighbor and check whether
+	// MAC changes of veth1 are properly handled. This is a basic randomized
+	// testing of insertNeighbor() fine-grained locking.
+	now = time.Now()
+	err = linuxNodeHandler.NodeAdd(nodev1)
+	c.Assert(err, check.IsNil)
+	wait(nodev1.Identity(), "veth0", &now, false)
+
+	rndHWAddr := func() net.HardwareAddr {
+		mac := make([]byte, 6)
+		_, err := rand.Read(mac)
+		c.Assert(err, check.IsNil)
+		mac[0] = (mac[0] | 2) & 0xfe
+		return net.HardwareAddr(mac)
+	}
+	neighRefCount := func(nextHopStr string) int {
+		linuxNodeHandler.neighLock.Lock()
+		defer linuxNodeHandler.neighLock.Unlock()
+		return linuxNodeHandler.neighNextHopRefCount[nextHopStr]
+	}
+
+	done := make(chan struct{})
+	count := 30
+	var wg sync.WaitGroup
+	wg.Add(count)
+	for i := 0; i < count; i++ {
+		go func() {
+			defer wg.Done()
+			ticker := time.NewTicker(100 * time.Millisecond)
+			for {
+				linuxNodeHandler.insertNeighbor(context.Background(), &nodev1, true)
+				select {
+				case <-ticker.C:
+				case <-done:
+					return
+				}
+			}
+		}()
+	}
+	for i := 0; i < 10; i++ {
+		mac := rndHWAddr()
+		// Change MAC
+		netns0.Do(func(ns.NetNS) error {
+			veth1, err := netlink.LinkByName("veth1")
+			c.Assert(err, check.IsNil)
+			err = netlink.LinkSetHardwareAddr(veth1, mac)
+			c.Assert(err, check.IsNil)
+			return nil
+		})
+
+		// Check that MAC has been changed in the neigh table
+		var found bool
+		err := testutils.WaitUntilWithSleep(func() bool {
+			neighs, err = netlink.NeighList(veth0.Attrs().Index, netlink.FAMILY_V4)
+			c.Assert(err, check.IsNil)
+			found = false
+			for _, n := range neighs {
+				if n.IP.Equal(ip1) && (n.State&netlink.NUD_REACHABLE) > 0 &&
+					n.HardwareAddr.String() == mac.String() &&
+					neighRefCount(ip1.String()) == 1 {
+					found = true
+					return true
+				}
+			}
+			return false
+		}, 25*time.Second, 200*time.Millisecond)
+		c.Assert(err, check.IsNil)
+		c.Assert(found, check.Equals, true)
+	}
+
+	// Cleanup
+	close(done)
+	wg.Wait()
+	now = time.Now()
+	err = linuxNodeHandler.NodeDelete(nodev1)
+	c.Assert(err, check.IsNil)
+	wait(nodev1.Identity(), "veth0", nil, true)
+
+	// Setup routine for the 2. test
+	setupRemoteNode := func(vethName, vethPeerName, netnsName, vethCIDR, vethIPAddr,
+		vethPeerIPAddr string) (cleanup func(), errRet error) {
+
+		veth := &netlink.Veth{
+			LinkAttrs: netlink.LinkAttrs{Name: vethName},
+			PeerName:  vethPeerName,
+		}
+		errRet = netlink.LinkAdd(veth)
+		if errRet != nil {
+			return nil, err
+		}
+		cleanup1 := func() { netlink.LinkDel(veth) }
+		cleanup = cleanup1
+
+		veth2, err := netlink.LinkByName(vethName)
+		if err != nil {
+			errRet = err
+			return
+		}
+		veth3, err := netlink.LinkByName(vethPeerName)
+		if err != nil {
+			errRet = err
+			return
+		}
+		netns1, err := netns.ReplaceNetNSWithName(netnsName)
+		if err != nil {
+			errRet = err
+			return
+		}
+		cleanup = func() {
+			cleanup1()
+			netns1.Close()
+		}
+		if errRet = netlink.LinkSetNsFd(veth2, int(netns0.Fd())); errRet != nil {
+			return
+		}
+		if errRet = netlink.LinkSetNsFd(veth3, int(netns1.Fd())); errRet != nil {
+			return
+		}
+
+		ip, ipnet, err := net.ParseCIDR(vethCIDR)
+		if err != nil {
+			errRet = err
+			return
+		}
+		ip2 := net.ParseIP(vethIPAddr)
+		ip3 := net.ParseIP(vethPeerIPAddr)
+		ipnet.IP = ip2
+
+		if errRet = netns0.Do(func(ns.NetNS) error {
+			addr = &netlink.Addr{IPNet: ipnet}
 			if err := netlink.AddrAdd(veth2, addr); err != nil {
 				return err
 			}
@@ -2193,7 +2563,7 @@ refetch2:
 	}
 	now = time.Now()
 	c.Assert(linuxNodeHandler.NodeAdd(nodev2), check.IsNil)
-	wait(nodev2.Identity(), &now, false)
+	wait(nodev2.Identity(), "veth0", &now, false)
 
 	node3IP := net.ParseIP("7.7.7.250")
 	nodev3 := nodeTypes.Node{
@@ -2201,7 +2571,7 @@ refetch2:
 		IPAddresses: []nodeTypes.Address{{nodeaddressing.NodeInternalIP, node3IP}},
 	}
 	c.Assert(linuxNodeHandler.NodeAdd(nodev3), check.IsNil)
-	wait(nodev3.Identity(), &now, false)
+	wait(nodev3.Identity(), "veth0", &now, false)
 
 	nextHop := net.ParseIP("9.9.9.250")
 refetch3:
@@ -2227,7 +2597,7 @@ refetch3:
 
 	// Check that removing node2 will not remove nextHop, as it is still used by node3
 	c.Assert(linuxNodeHandler.NodeDelete(nodev2), check.IsNil)
-	wait(nodev2.Identity(), nil, true)
+	wait(nodev2.Identity(), "veth0", nil, true)
 	neighs, err = netlink.NeighList(veth0.Attrs().Index, netlink.FAMILY_V4)
 	found = false
 	for _, n := range neighs {
@@ -2240,7 +2610,7 @@ refetch3:
 
 	// However, removing node3 should remove the neigh entry for nextHop
 	c.Assert(linuxNodeHandler.NodeDelete(nodev3), check.IsNil)
-	wait(nodev3.Identity(), nil, true)
+	wait(nodev3.Identity(), "veth0", nil, true)
 
 	found = false
 	neighs, err = netlink.NeighList(veth0.Attrs().Index, netlink.FAMILY_V4)
@@ -2255,7 +2625,7 @@ refetch3:
 
 	now = time.Now()
 	c.Assert(linuxNodeHandler.NodeAdd(nodev3), check.IsNil)
-	wait(nodev3.Identity(), &now, false)
+	wait(nodev3.Identity(), "veth0", &now, false)
 
 	nextHop = net.ParseIP("9.9.9.250")
 refetch4:
@@ -2323,11 +2693,11 @@ refetch5:
 	// deleted from the neighbor table as well as the new one added.
 	now = time.Now()
 	c.Assert(linuxNodeHandler.NodeAdd(nodev2), check.IsNil)
-	wait(nodev2.Identity(), &now, false)
+	wait(nodev2.Identity(), "veth0", &now, false)
 
 	now = time.Now()
 	c.Assert(linuxNodeHandler.NodeAdd(nodev3), check.IsNil)
-	wait(nodev3.Identity(), &now, false)
+	wait(nodev3.Identity(), "veth0", &now, false)
 
 	nextHop = net.ParseIP("9.9.9.250")
 refetch6:
@@ -2356,11 +2726,15 @@ refetch6:
 	c.Assert(err, check.IsNil)
 
 	// waitGw waits for the nextHop to appear in the agent's nextHop table
-	waitGw := func(nextHopNew string, nodeID nodeTypes.Identity, before *time.Time) {
+	waitGw := func(nextHopNew string, nodeID nodeTypes.Identity, link string, before *time.Time) {
 		err := testutils.WaitUntil(func() bool {
 			linuxNodeHandler.neighLock.Lock()
 			defer linuxNodeHandler.neighLock.Unlock()
-			nextHop, found := linuxNodeHandler.neighNextHopByNode4[nodeID]
+			nextHopByLink, found := linuxNodeHandler.neighNextHopByNode4[nodeID]
+			if !found {
+				return false
+			}
+			nextHop, found := nextHopByLink[link]
 			if !found {
 				return false
 			}
@@ -2380,8 +2754,8 @@ refetch6:
 	now = time.Now()
 	linuxNodeHandler.NodeNeighborRefresh(context.Background(), nodev2)
 	linuxNodeHandler.NodeNeighborRefresh(context.Background(), nodev3)
-	waitGw("9.9.9.251", nodev2.Identity(), &now)
-	waitGw("9.9.9.250", nodev3.Identity(), &now)
+	waitGw("9.9.9.251", nodev2.Identity(), "veth0", &now)
+	waitGw("9.9.9.250", nodev3.Identity(), "veth0", &now)
 
 	// Both nextHops now need to be present
 	nextHop = net.ParseIP("9.9.9.250")
@@ -2434,8 +2808,8 @@ refetch8:
 	now = time.Now()
 	linuxNodeHandler.NodeNeighborRefresh(context.Background(), nodev2)
 	linuxNodeHandler.NodeNeighborRefresh(context.Background(), nodev3)
-	waitGw("9.9.9.251", nodev2.Identity(), &now)
-	waitGw("9.9.9.251", nodev3.Identity(), &now)
+	waitGw("9.9.9.251", nodev2.Identity(), "veth0", &now)
+	waitGw("9.9.9.251", nodev3.Identity(), "veth0", &now)
 
 	nextHop = net.ParseIP("9.9.9.250")
 refetch9:
@@ -2482,7 +2856,7 @@ refetch10:
 	c.Assert(found, check.Equals, true)
 
 	c.Assert(linuxNodeHandler.NodeDelete(nodev3), check.IsNil)
-	wait(nodev3.Identity(), nil, true)
+	wait(nodev3.Identity(), "veth0", nil, true)
 
 	// In the next test, we have node2 left in the neighbor table, and
 	// we add an unrelated externally learned neighbor entry. Check that
@@ -2551,11 +2925,366 @@ refetch11:
 	c.Assert(found, check.Equals, true)
 
 	c.Assert(linuxNodeHandler.NodeDelete(nodev2), check.IsNil)
-	wait(nodev2.Identity(), nil, true)
+	wait(nodev2.Identity(), "veth0", nil, true)
 
 	linuxNodeHandler.NodeCleanNeighborsLink(veth0, false)
 }
 
+func (s *linuxPrivilegedIPv4OnlyTestSuite) TestArpPingHandlingForMultiDevice(c *check.C) {
+	runtime.LockOSThread()
+	defer runtime.UnlockOSThread()
+
+	prevEnableL2NeighDiscovery := option.Config.EnableL2NeighDiscovery
+	defer func() { option.Config.EnableL2NeighDiscovery = prevEnableL2NeighDiscovery }()
+
+	option.Config.EnableL2NeighDiscovery = true
+
+	prevStateDir := option.Config.StateDir
+	defer func() { option.Config.StateDir = prevStateDir }()
+
+	tmpDir := c.MkDir()
+	option.Config.StateDir = tmpDir
+
+	baseTimeOld, err := sysctl.Read(baseIPv4Time)
+	c.Assert(err, check.IsNil)
+	err = sysctl.Write(baseIPv4Time, fmt.Sprintf("%d", 2500))
+	c.Assert(err, check.IsNil)
+	defer func() { sysctl.Write(baseIPv4Time, baseTimeOld) }()
+
+	// 1. Test whether another node in the same L2 subnet can be arpinged.
+	//    Each node has two devices and the other node in the different netns
+	//    is reachable via either pair.
+	//
+	//      +--------------+     +--------------+
+	//      |  host netns  |     |    netns1    |
+	//      |              |     |    nodev1    |
+	//      |              |     |  10.0.0.1/32 |
+	//      |         veth0+-----+veth1         |
+	//      |          |   |     |   |          |
+	//      | 9.9.9.249/29 |     |9.9.9.250/29  |
+	//      |              |     |              |
+	//      |         veth2+-----+veth3         |
+	//      |          |   |     | |            |
+	//      | 8.8.8.249/29 |     | 8.8.8.250/29 |
+	//      +--------------+     +--------------+
+
+	// Setup
+	vethPair01 := &netlink.Veth{
+		LinkAttrs: netlink.LinkAttrs{Name: "veth0"},
+		PeerName:  "veth1",
+	}
+	err = netlink.LinkAdd(vethPair01)
+	c.Assert(err, check.IsNil)
+	defer netlink.LinkDel(vethPair01)
+	veth0, err := netlink.LinkByName("veth0")
+	c.Assert(err, check.IsNil)
+	veth1, err := netlink.LinkByName("veth1")
+	c.Assert(err, check.IsNil)
+	_, ipnet, err := net.ParseCIDR("9.9.9.252/29")
+	v1IP0 := net.ParseIP("9.9.9.249")
+	v1IP1 := net.ParseIP("9.9.9.250")
+	v1IPG := net.ParseIP("9.9.9.251")
+	ipnet.IP = v1IP0
+	addr := &netlink.Addr{IPNet: ipnet}
+	err = netlink.AddrAdd(veth0, addr)
+	c.Assert(err, check.IsNil)
+	err = netlink.LinkSetUp(veth0)
+	c.Assert(err, check.IsNil)
+
+	netns0, err := netns.ReplaceNetNSWithName("test-arping-netns0")
+	c.Assert(err, check.IsNil)
+	defer netns0.Close()
+	err = netlink.LinkSetNsFd(veth1, int(netns0.Fd()))
+	c.Assert(err, check.IsNil)
+	err = netns0.Do(func(ns.NetNS) error {
+		lo, err := netlink.LinkByName("lo")
+		c.Assert(err, check.IsNil)
+		err = netlink.LinkSetUp(lo)
+		c.Assert(err, check.IsNil)
+		addr, err := netlink.ParseAddr("10.0.0.1/32")
+		c.Assert(err, check.IsNil)
+		err = netlink.AddrAdd(lo, addr)
+		c.Assert(err, check.IsNil)
+
+		veth1, err := netlink.LinkByName("veth1")
+		c.Assert(err, check.IsNil)
+		ipnet.IP = v1IP1
+		addr = &netlink.Addr{IPNet: ipnet}
+		err = netlink.AddrAdd(veth1, addr)
+		c.Assert(err, check.IsNil)
+		ipnet.IP = v1IPG
+		addr = &netlink.Addr{IPNet: ipnet}
+		err = netlink.AddrAdd(veth1, addr)
+		c.Assert(err, check.IsNil)
+		err = netlink.LinkSetUp(veth1)
+		c.Assert(err, check.IsNil)
+		return nil
+	})
+	c.Assert(err, check.IsNil)
+
+	vethPair23 := &netlink.Veth{
+		LinkAttrs: netlink.LinkAttrs{Name: "veth2"},
+		PeerName:  "veth3",
+	}
+	err = netlink.LinkAdd(vethPair23)
+	c.Assert(err, check.IsNil)
+	defer netlink.LinkDel(vethPair23)
+	veth2, err := netlink.LinkByName("veth2")
+	c.Assert(err, check.IsNil)
+	veth3, err := netlink.LinkByName("veth3")
+	c.Assert(err, check.IsNil)
+	_, ipnet, err = net.ParseCIDR("8.8.8.252/29")
+	v2IP0 := net.ParseIP("8.8.8.249")
+	v2IP1 := net.ParseIP("8.8.8.250")
+	v2IPG := net.ParseIP("8.8.8.251")
+	ipnet.IP = v2IP0
+	addr = &netlink.Addr{IPNet: ipnet}
+	err = netlink.AddrAdd(veth2, addr)
+	c.Assert(err, check.IsNil)
+	err = netlink.LinkSetUp(veth2)
+	c.Assert(err, check.IsNil)
+
+	err = netlink.LinkSetNsFd(veth3, int(netns0.Fd()))
+	c.Assert(err, check.IsNil)
+	err = netns0.Do(func(ns.NetNS) error {
+		veth3, err := netlink.LinkByName("veth3")
+		c.Assert(err, check.IsNil)
+		ipnet.IP = v2IP1
+		addr = &netlink.Addr{IPNet: ipnet}
+		err = netlink.AddrAdd(veth3, addr)
+		c.Assert(err, check.IsNil)
+		ipnet.IP = v2IPG
+		addr = &netlink.Addr{IPNet: ipnet}
+		err = netlink.AddrAdd(veth3, addr)
+		c.Assert(err, check.IsNil)
+		err = netlink.LinkSetUp(veth3)
+		c.Assert(err, check.IsNil)
+		return nil
+	})
+	c.Assert(err, check.IsNil)
+
+	r := &netlink.Route{
+		Dst: netlink.NewIPNet(net.ParseIP("10.0.0.1")),
+		MultiPath: []*netlink.NexthopInfo{
+			{
+				LinkIndex: veth0.Attrs().Index,
+				Gw:        v1IP1,
+			},
+			{
+				LinkIndex: veth2.Attrs().Index,
+				Gw:        v2IP1,
+			},
+		}}
+	err = netlink.RouteAdd(r)
+	c.Assert(err, check.IsNil)
+	defer netlink.RouteDel(r)
+
+	prevTunnel := option.Config.Tunnel
+	defer func() { option.Config.Tunnel = prevTunnel }()
+	option.Config.Tunnel = option.TunnelDisabled
+	prevDRDev := option.Config.DirectRoutingDevice
+	defer func() { option.Config.DirectRoutingDevice = prevDRDev }()
+	option.Config.DirectRoutingDevice = "veth0"
+	prevDevices := option.Config.Devices
+	defer func() { option.Config.Devices = prevDevices }()
+	option.Config.Devices = []string{"veth0", "veth2"}
+	prevNP := option.Config.EnableNodePort
+	defer func() { option.Config.EnableNodePort = prevNP }()
+	option.Config.EnableNodePort = true
+	dpConfig := DatapathConfiguration{HostDevice: "veth0"}
+	prevARPPeriod := option.Config.ARPPingRefreshPeriod
+	defer func() { option.Config.ARPPingRefreshPeriod = prevARPPeriod }()
+	option.Config.ARPPingRefreshPeriod = 1 * time.Nanosecond
+
+	linuxNodeHandler := NewNodeHandler(dpConfig, s.nodeAddressing, nil).(*linuxNodeHandler)
+	c.Assert(linuxNodeHandler, check.Not(check.IsNil))
+
+	err = linuxNodeHandler.NodeConfigurationChanged(datapath.LocalNodeConfiguration{
+		EnableEncapsulation: false,
+		EnableIPv4:          s.enableIPv4,
+		EnableIPv6:          s.enableIPv6,
+	})
+	c.Assert(err, check.IsNil)
+
+	// wait waits for neigh entry update or waits for removal if waitForDelete=true
+	wait := func(nodeID nodeTypes.Identity, link string, before *time.Time, waitForDelete bool) {
+		err := testutils.WaitUntil(func() bool {
+			linuxNodeHandler.neighLock.Lock()
+			defer linuxNodeHandler.neighLock.Unlock()
+			nextHopByLink, found := linuxNodeHandler.neighNextHopByNode4[nodeID]
+			if !found {
+				return waitForDelete
+			}
+			nextHop, found := nextHopByLink[link]
+			if !found {
+				return waitForDelete
+			}
+			lastPing, found := linuxNodeHandler.neighLastPingByNextHop[nextHop]
+			if !found {
+				return false
+			}
+			if waitForDelete {
+				return false
+			}
+			return before.Before(lastPing)
+		}, 5*time.Second)
+		c.Assert(err, check.IsNil)
+	}
+
+	nodev1 := nodeTypes.Node{
+		Name:        "node1",
+		IPAddresses: []nodeTypes.Address{{nodeaddressing.NodeInternalIP, net.ParseIP("10.0.0.1")}},
+	}
+	now := time.Now()
+	err = linuxNodeHandler.NodeAdd(nodev1)
+	c.Assert(err, check.IsNil)
+	// insertNeighbor is invoked async
+	// Insert the same node second time. This should not increment refcount for
+	// the same nextHop. We test it by checking that NodeDelete has removed the
+	// related neigh entry.
+	err = linuxNodeHandler.NodeAdd(nodev1)
+	c.Assert(err, check.IsNil)
+	// insertNeighbor is invoked async, so thus this wait based on last ping
+	wait(nodev1.Identity(), "veth0", &now, false)
+	wait(nodev1.Identity(), "veth2", &now, false)
+refetch1:
+	// Check whether an arp entry for nodev1 IP addr (=veth1) was added
+	neighs, err := netlink.NeighList(veth0.Attrs().Index, netlink.FAMILY_V4)
+	c.Assert(err, check.IsNil)
+	found := false
+	for _, n := range neighs {
+		if n.IP.Equal(v1IP1) {
+			good, retry := neighStateOk(n)
+			if good {
+				found = true
+				break
+			}
+			if retry {
+				goto refetch1
+			}
+		}
+	}
+	c.Assert(found, check.Equals, true)
+
+refetch2:
+	// Check whether an arp entry for nodev1 IP addr (=veth3) was added
+	neighs, err = netlink.NeighList(veth2.Attrs().Index, netlink.FAMILY_V4)
+	c.Assert(err, check.IsNil)
+	found = false
+	for _, n := range neighs {
+		if n.IP.Equal(v2IP1) {
+			good, retry := neighStateOk(n)
+			if good {
+				found = true
+				break
+			}
+			if retry {
+				goto refetch2
+			}
+		}
+	}
+	c.Assert(found, check.Equals, true)
+
+	// Swap MAC addresses of veth0 and veth1, veth2 and veth3 to ensure the MAC address of veth1 changed.
+	// Trigger neighbor refresh on veth0 and check whether the arp entry was updated.
+	var veth0HwAddr, veth1HwAddr, veth2HwAddr, veth3HwAddr, updatedHwAddrFromArpEntry net.HardwareAddr
+	veth0HwAddr = veth0.Attrs().HardwareAddr
+	veth2HwAddr = veth2.Attrs().HardwareAddr
+	err = netns0.Do(func(ns.NetNS) error {
+		veth1, err := netlink.LinkByName("veth1")
+		c.Assert(err, check.IsNil)
+		veth1HwAddr = veth1.Attrs().HardwareAddr
+		err = netlink.LinkSetHardwareAddr(veth1, veth0HwAddr)
+		c.Assert(err, check.IsNil)
+
+		veth3, err := netlink.LinkByName("veth3")
+		c.Assert(err, check.IsNil)
+		veth3HwAddr = veth3.Attrs().HardwareAddr
+		err = netlink.LinkSetHardwareAddr(veth3, veth2HwAddr)
+		c.Assert(err, check.IsNil)
+		return nil
+	})
+	c.Assert(err, check.IsNil)
+
+	now = time.Now()
+	err = netlink.LinkSetHardwareAddr(veth0, veth1HwAddr)
+	c.Assert(err, check.IsNil)
+	err = netlink.LinkSetHardwareAddr(veth2, veth3HwAddr)
+	c.Assert(err, check.IsNil)
+
+	linuxNodeHandler.NodeNeighborRefresh(context.TODO(), nodev1)
+	wait(nodev1.Identity(), "veth0", &now, false)
+	wait(nodev1.Identity(), "veth2", &now, false)
+refetch3:
+	neighs, err = netlink.NeighList(veth0.Attrs().Index, netlink.FAMILY_V4)
+	c.Assert(err, check.IsNil)
+	found = false
+	for _, n := range neighs {
+		if n.IP.Equal(v1IP1) {
+			good, retry := neighStateOk(n)
+			if good {
+				found = true
+				updatedHwAddrFromArpEntry = n.HardwareAddr
+				break
+			}
+			if retry {
+				goto refetch3
+			}
+		}
+	}
+	c.Assert(found, check.Equals, true)
+	c.Assert(updatedHwAddrFromArpEntry.String(), check.Equals, veth0HwAddr.String())
+
+refetch4:
+	neighs, err = netlink.NeighList(veth2.Attrs().Index, netlink.FAMILY_V4)
+	c.Assert(err, check.IsNil)
+	found = false
+	for _, n := range neighs {
+		if n.IP.Equal(v2IP1) {
+			good, retry := neighStateOk(n)
+			if good {
+				found = true
+				updatedHwAddrFromArpEntry = n.HardwareAddr
+				break
+			}
+			if retry {
+				goto refetch4
+			}
+		}
+	}
+	c.Assert(found, check.Equals, true)
+	c.Assert(updatedHwAddrFromArpEntry.String(), check.Equals, veth2HwAddr.String())
+
+	// Remove nodev1, and check whether the arp entry was removed
+	err = linuxNodeHandler.NodeDelete(nodev1)
+	c.Assert(err, check.IsNil)
+	// deleteNeighbor is invoked async too
+	wait(nodev1.Identity(), "veth0", nil, true)
+	wait(nodev1.Identity(), "veth2", nil, true)
+
+	neighs, err = netlink.NeighList(veth0.Attrs().Index, netlink.FAMILY_V4)
+	c.Assert(err, check.IsNil)
+	found = false
+	for _, n := range neighs {
+		if n.IP.Equal(v1IP1) {
+			found = true
+			break
+		}
+	}
+	c.Assert(found, check.Equals, false)
+
+	neighs, err = netlink.NeighList(veth2.Attrs().Index, netlink.FAMILY_V4)
+	c.Assert(err, check.IsNil)
+	found = false
+	for _, n := range neighs {
+		if n.IP.Equal(v2IP1) {
+			found = true
+			break
+		}
+	}
+	c.Assert(found, check.Equals, false)
+}
+
 func (s *linuxPrivilegedBaseTestSuite) benchmarkNodeUpdate(c *check.C, config datapath.LocalNodeConfiguration) {
 	ip4Alloc1 := cidr.MustParseCIDR("5.5.5.0/24")
 	ip4Alloc2 := cidr.MustParseCIDR("6.6.6.0/24")
diff --git a/pkg/datapath/linux/node_test.go b/pkg/datapath/linux/node_test.go
index 408ae73e7e..5f34729f33 100644
--- a/pkg/datapath/linux/node_test.go
+++ b/pkg/datapath/linux/node_test.go
@@ -101,7 +101,7 @@ func (s *linuxTestSuite) TestCreateNodeRouteSpecMtu(c *check.C) {
 
 func (s *linuxTestSuite) TestStoreLoadNeighLinks(c *check.C) {
 	tmpDir := c.MkDir()
-	devExpected := "dev1"
+	devExpected := []string{"dev1"}
 	err := storeNeighLink(tmpDir, devExpected)
 	c.Assert(err, check.IsNil)
 
